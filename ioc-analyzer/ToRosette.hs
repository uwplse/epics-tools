module ToRosette(toRosette) where

{-

Given a database, this code writes Rosette (https://github.com/emina/rosette)
code to interpret it.

NOTES:
 - EPICS treats everything as double-precision floats and converts to-and-from
   integers (TODO: what bit width??) when needed. This code models everything
   as 16-bit ints. (TODO: figure out if this is OK for Jon's code.)

-}

import Data.Char(ord, isAlphaNum)
import Data.List(sort, elemIndex)
import qualified Data.Map as M
import Debug.Trace(trace)
import Data.Maybe(fromJust)
import Data.Int(Int8)

import qualified Record
import Record hiding (r_type)
import Parser(maybeRead, substStringToStr)
import FieldInfo
import Fields
import ExpParser
import Parser(StringPart(..))

-- Various output routines
notImplemented s = error $ "NOT IMPLEMENTED: " ++ s
warning s = trace $ "WARNING: " ++ s
warningInRecord r s = warning $ "in record " ++ recordNameToStr (r_name r) ++ ": " ++ s
errorInRecord r s = error $ "in record " ++ recordNameToStr (r_name r) ++ ": " ++ s

-- According to http://www.aps.anl.gov/bcda/synApps/calc/calcReleaseNotes.html,
-- the semantics of "a{i,j}" changed in version 3-0 of the calc extensions
-- module. This flag controls whether we use the old semantics (inclusive-
-- exclusive bounds) or the new semantics (inclusive-inclusive bounds).
data SliceSemantics = InclusiveExclusive | InclusiveInclusive deriving (Eq, Ord, Show)
sliceSemantics = InclusiveInclusive

toRosette :: Database -> String
toRosette db =
  "#lang rosette\n" ++
  "; THIS IS AN AUTOGENERATED FILE\n" ++
  "(require \"dbcore.rkt\")\n" ++
  "(require \"env.rkt\")\n" ++
  "(require \"tracing.rkt\")\n" ++
  "(provide (all-defined-out))\n" ++

  --"(define db-verbose #f)\n" ++
  --"(define (db-set-verbose! val) (set! db-verbose val))\n" ++

  "(define current-db (new-symbolic-database))\n" ++
  "(define (set-current-db! new-db) (set! current-db new-db))\n" ++
  "(define (db-init-symbolic) (set-current-db! (new-symbolic-database)))\n" ++
  "(define (db-init-concrete)\n" ++
    "(set-current-db! (new-concrete-database))\n" ++
    initConcreteFields db ++ ")\n" ++

  "(define start-processing-hook (lambda (r) #f))\n" ++
  "(define (set-start-processing-hook! hook) (set! start-processing-hook hook))\n" ++
  "(define end-processing-hook (lambda (r) #f))\n" ++
  "(define (set-end-processing-hook! hook) (set! end-processing-hook hook))\n" ++

  --concatMap (uncurry makeType) (M.toList fieldtypes) ++
  makeTypes db ++

  "(define (get-field r f) (db-get current-db r f (field-type r f)))\n" ++
  "(define (set-field r f val) (db-put! current-db r f (field-type r f) val))\n" ++

  let records = (deduplicateRecords db) in
  concatMap (recordToRosette db) records ++
  makeProcessRoutine db

-- What fields are mutable? These will be reflected in the generated database.
isMutable :: String -> FieldName -> Bool
isMutable rty f
  | f `elem` ["PACT", "RVAL", "VAL", "PROC", "STAT", "SEVR"] = True
  | rty == "seq"      = f `elem` seqVars
  | rty == "calc"     = f `elem` calcVars
  | rty == "calcout"  = f `elem` calcVars || f == "OVAL"
  | rty == "acalcout" = f `elem` acalcoutVars || f `elem` calcVars || f `elem` ["AVAL", "OVAL", "OAV"]
  | rty == "scalcout" = f `elem` acalcoutVars || f `elem` calcVars || f `elem` ["SVAL", "OVAL", "OSV"]
  | otherwise = False

r_type = substStringToStr . (Record.r_type)

keys = map fst . M.toList

initConcreteFields :: Database -> String
initConcreteFields db =
  flip concatMap db (\r ->
    flip concatMap [f | f <- keys (allFields r), isMutable (r_type r) f] (\f ->
      if definesValueForField r f
        then set r f (makeConcreteValueForField r f)
        else ""))

deduplicateRecords :: Database -> Database
deduplicateRecords = helper []
  where
    helper _ [] = []
    helper seen (r:db)
      | r_name r `elem` seen = warning ("omitting duplicate record " ++ recordNameToStr (r_name r)) (helper seen db)
      | otherwise = r : helper (r_name r : seen) db

makeProcessRoutine :: Database -> String
makeProcessRoutine db =
  "(define process-procedure-by-name " ++ makeImHash [(show $ recordNameToStr $ r_name r, "process_" ++ mangleRecord (r_name r)) | r <- db] ++ ")\n" ++
  "(define (process record) ((hash-ref process-procedure-by-name record (thunk (eprintf \"no record ~s\\n\" record)))))\n"

-- create a new symbolic value of the given type
makeSymbolicValue :: String -> RealType -> String
makeSymbolicValue name Boolean = "(get-symb " ++ show name ++ " boolean?)"
makeSymbolicValue name Character = makeSymbolicValue name i8
makeSymbolicValue name (SBitVec width) = "(get-symb " ++ show name ++ " (bitvector " ++ show width ++ "))"
makeSymbolicValue name (UBitVec width) = makeSymbolicValue name (SBitVec width)
makeSymbolicValue name (FP ex si) = symbolicFloat ex si name
makeSymbolicValue name (Vector n t) =
  let vs = map (\i -> makeSymbolicValue (name ++ "[" ++ show i ++ "]") t) [0 .. (n-1)] in
  "(vector" ++ concatMap (' ':) vs ++ ")"

recordToRosette :: Database -> Record -> String
recordToRosette db r = mkProcRoutine db r

data RealType =
  Boolean | Character |
  SBitVec Integer |         -- integer argument is bit width; it must be >
  UBitVec Integer |         -- integer argument is bit width; it must be >0
  FP Integer Integer |      -- arguments are exponent width and significand width
  Vector Integer RealType   -- fixed-length vector
  deriving (Eq, Ord)

instance Show RealType where
  show Boolean = "bool"
  show Character = "char"
  show (SBitVec w) = 'i' : show w
  show (UBitVec w) = 'u' : show w
  show f@(FP ex si)
    | f == f32  = "float"
    | f == f64  = "double"
    | otherwise = "fp" ++ show ex ++ "_" ++ show si
  show (Vector n t) = show t ++ "[" ++ show n ++ "]"

-- A few common type declarations
i8  = SBitVec 8
i16 = SBitVec 16
i32 = SBitVec 32
u8  = UBitVec 8
u16 = UBitVec 16
u32 = UBitVec 32
f32 = FP  8 24
f64 = FP 11 53

-- Not all the type information is directly present in the db. We actually have
-- to read some fields to figure out what the types should be. This function
-- will probably need to be extended to handle additional records eventually.
realType :: Record -> FieldName -> RealType
realType r f
  | (r_type r) `elem` ["waveform", "subArray"], f == "VAL" = Vector (arrLen r) (typeDenote (arrTy r))
  | (r_type r) == "acalcout", f `elem` ("AVAL" : "OAV" : acalcoutVars) = Vector (arrLen r) f64
  | otherwise = typeDenote (typeOfField r f)

makeImHash :: [(String, String)] -> String
makeImHash vs = "(make-immutable-hash (list" ++ concatMap (\(k, v) -> " (cons " ++ k ++ " " ++ v ++ ")") vs ++ "))"

makeList :: [String] -> String
makeList vs = "(list" ++ concatMap (' ':) vs ++ ")"

makeTypes :: Database -> String
makeTypes db =
  "(define all-records (list" ++ concatMap (\r -> ' ' : show (recordNameToStr (r_name r))) db ++ "))\n" ++
  "(define fields-of-type_ " ++ makeImHash [(show rt, makeList [show fn | (fn, t) <- M.toList fields, isMutable rt fn]) | (rt, fields) <- M.toList fieldtypes] ++ ")\n" ++
  "(define (fields-of-type t) (hash-ref fields-of-type_ t))\n" ++
  "(define record-type_ " ++ makeImHash (map (\r -> (show $ recordNameToStr $ r_name r, show $ r_type r)) db) ++ ")\n" ++
  "(define (record-type r) (hash-ref record-type_ r))\n" ++
  "(define arr-len_ " ++ makeImHash [(show $ recordNameToStr $ r_name r, show $ arrLen r) | r <- db, (r `hasField` "NELM" || r_type r == "scalcout") && arrLen r /= 0] ++ ")\n" ++
  "(define (arr-len r) (hash-ref arr-len_ r 0))\n" ++
  "(define arr-ty_ " ++ makeImHash [(show $ recordNameToStr $ r_name r, typeToRosette $ typeDenote $ arrTy r) | r <- db, r_type r `elem` ["acalcout", "waveform", "subArray"]] ++ ")\n" ++
  "(define (arr-ty r) (hash-ref arr-ty_ r))\n" ++
  "(define field-type_ " ++ makeImHash [(
      show $ recordNameToStr $ r_name r,
      makeImHash [(
        show f,
        computeFieldType (show $ recordNameToStr $ r_name r) (r_type r) f ft)
      | (f, ft) <- M.toList (fromJust $ M.lookup (r_type r) fieldtypes), isMutable (r_type r) f])
    | r <- db] ++ ")\n" ++
  "(define (field-type r f) (hash-ref (hash-ref field-type_ r) f))\n"
  where
    computeFieldType record recordType fieldName fieldType =
      case (recordType, fieldName) of
        ("acalcout", _) | fieldName `elem` ("AVAL" : "OAV" : acalcoutVars) -> "(vector (arr-len " ++ record ++ ") (bitvector 64))"
        ("waveform", "VAL") -> "(vector (arr-len " ++ record ++ ") (arr-ty " ++ record ++ "))"
        ("subArray", "VAL") -> "(vector (arr-len " ++ record ++ ") (arr-ty " ++ record ++ "))"
        _ -> typeToRosette (typeDenote $ fromJust $ M.lookup fieldName $ fromJust $ M.lookup recordType fieldtypes)
    typeToRosette Boolean = "boolean?"
    typeToRosette Character = typeToRosette (SBitVec 8)
    typeToRosette (SBitVec w) = "(bitvector " ++ show w ++ ")"
    typeToRosette (UBitVec w) = typeToRosette (SBitVec w)
    typeToRosette (FP ex si) = typeToRosette (SBitVec $ ex + si)
    typeToRosette (Vector n t) = "(vector " ++ show n ++ " " ++ typeToRosette t ++ ")"

typeDenote :: FieldType -> RealType
typeDenote (MENU _) = u16 -- see epicsTypes.h
typeDenote ENUM     = u16 -- see epicsTypes.h
typeDenote UCHAR    = u8
typeDenote CHAR     = i8
typeDenote USHORT   = u16
typeDenote SHORT    = i16
typeDenote ULONG    = u32
typeDenote LONG     = i32
typeDenote FLOAT    = f32
typeDenote DOUBLE   = f64
typeDenote (STRING n) = Vector n Character
typeDenote t        = warning ("not sure how to handle EPICS type " ++ show t) i16

truncateDoubleToInt :: Record -> Double -> Integer
truncateDoubleToInt r n =
  let i = (floor n) :: Integer in
    if fromIntegral i == n
      then i
      else warning ("truncated " ++ show n ++ " to " ++ show i ++ " in record " ++ recordNameToStr (r_name r)) i

truncateDouble :: Record -> Double -> String
truncateDouble r n = show $ truncateDoubleToInt r n

mkZero (FP ex si) = fpzero ex si
mkZero (SBitVec w) = bv 0 w
mkZero (UBitVec w) = bv 0 w
mkZero Boolean = "false"
mkZero Character = bv 0 8
mkZero (Vector n t) = "(vector" ++ concatMap (const $ ' ' : mkZero t) [1..n] ++ ")"

parseConcreteValue :: Record -> String -> RealType -> String
parseConcreteValue r val (Vector n Character) =
  "(vector" ++
    concatMap (\v -> ' ' : bv (ord v) 8) (take (fromIntegral n) val) ++
    concatMap (\i -> ' ' : bv 0       8) [(length val + 1) .. (fromIntegral n)] ++ ")"
parseConcreteValue r "" (Vector n t) =
  "(vector" ++ concatMap (\i -> ' ' : mkZero t) [1 .. (fromIntegral n)] ++ ")"
parseConcreteValue r val (SBitVec width) =
  case val of
    "" -> bv 0 width
    _ | Just n <- (maybeRead val :: Maybe Integer) -> bv n width
parseConcreteValue r val (UBitVec width) =
  parseConcreteValue r val (SBitVec width)
parseConcreteValue r val (FP ex si) =
  fp2rosette ex si r val
parseConcreteValue r val t = error $ "unable to parse " ++ show val ++ " as " ++ show t

makeConcreteValueForField :: Record -> FieldName -> String
makeConcreteValueForField r f =
  case typeOfField r f of
    MENU _ -> menuToValue r f (readField r f)
    _ -> parseConcreteValue r (readField r f) (realType r f)

mangleRecord :: RecordName -> String
mangleRecord = filter isAlphaNum . recordNameToStr

setCore :: String -> String -> FieldName -> String -> String
setCore t rname f val =
  "(begin (record-trace (WriteField " ++ show rname ++ " " ++ show f ++ " " ++ val ++ "))" ++
    "(set-field " ++ show rname ++ " " ++ show f ++ " " ++ val ++ "))\n"

set :: Record -> FieldName -> String -> String
set r f v =
  if isMutable (r_type r) f
    then setCore (r_type r) (recordNameToStr (r_name r)) f v
    else warning ("write to non-mutable field " ++ f ++ " of " ++ r_type r ++ " record " ++ recordNameToStr (r_name r)) ""

getCore :: String -> String -> FieldName -> String
getCore t rname f =
  "(get-field " ++ show rname ++ " " ++ show f ++ ")"

get :: Record -> FieldName -> String
get r f =
  if isMutable (r_type r) f
    then getCore (r_type r) (recordNameToStr (r_name r)) f
    else makeConcreteValueForField r f

-- TODO: proper floating point operations
symbolicFloat ex si name = makeSymbolicValue name (SBitVec $ ex + si)
fp2rosette ex si r str =
  let width = ex + si in
  case str of
    "" -> fpzero ex si
    v | Just i <- maybeRead v -> bv (i :: Integer) width
    v | Just n <- (maybeRead v :: Maybe Double) -> "(bv " ++ truncateDouble r n ++ " " ++ show width ++ ")"
    _ -> warningInRecord r ("unable to make concrete value out of '" ++ str ++ "'; using 0 instead") fpzero ex si
fp2bv ex si e width = fromJust $ coerce (SBitVec (ex + si)) e (SBitVec width)
bv2fp width e ex si = fromJust $ coerce (SBitVec width) e (SBitVec (ex + si))
fpabs ex si e = bvsabs (ex + si) e
fpeq ex si e1 e2 = "(bveq " ++ e1 ++ " " ++ e2 ++ ")"
fpsub ex si e1 e2 = "(bvsub " ++ e1 ++ " " ++ e2 ++ ")"
fpadd ex si e1 e2 = "(bvadd " ++ e1 ++ " " ++ e2 ++ ")"
fpmul ex si e1 e2 = "(bvmul " ++ e1 ++ " " ++ e2 ++ ")"
fpdiv ex si e1 e2 = "(bvsdiv " ++ e1 ++ " " ++ e2 ++ ")"
fpnan ex si = fpzero ex si
fpzero ex si = "(bv 0 " ++ show (ex + si) ++ ")"
fpone ex si = "(bv 1 " ++ show (ex + si) ++ ")"
fpiszero ex si e = fpeq ex si e (fpzero ex si)
fpfloor ex si e = e
fpceil ex si e = e
fplt ex si e1 e2 = "(bvslt " ++ e1 ++ " " ++ e2 ++ ")"
fple ex si e1 e2 = "(bvsle " ++ e1 ++ " " ++ e2 ++ ")"
fpgt ex si e1 e2 = "(bvsgt " ++ e1 ++ " " ++ e2 ++ ")"
fpge ex si e1 e2 = "(bvsge " ++ e1 ++ " " ++ e2 ++ ")"

bvsabs w e = "(let ([v " ++ e ++ "]) (if (bvslt v (bv 0 " ++ show w ++ ")) (bvneg v) v))"

bv :: (Integral a, Show a, Integral b, Show b) => a -> b -> String
bv n width = "(bv " ++ show n ++ " " ++ show width ++ ")"

isVector (Vector _ _) = True
isVector _ = False

-- coerce t1 e t2 ---> convert expression e of type t1 to type t2
-- returns Nothing if no coersion exists
coerce :: RealType -> String -> RealType -> Maybe String
coerce t1 e t2 | t1 == t2 = Just e
coerce (SBitVec w1) e (SBitVec w2)
  | w1 == w2  = Just e
  | w1 >  w2  = Just $ "(extract " ++ show (w2 - 1) ++ " 0 " ++ e ++ ")"
  | otherwise = Just $ "(sign-extend " ++ e ++ " (bitvector " ++ show w2 ++ "))"
coerce (SBitVec w1) e (UBitVec w2) = coerce (SBitVec w1) e (SBitVec w2)
coerce (UBitVec w1) e (SBitVec w2) = coerce (SBitVec w1) e (SBitVec w2)
coerce (UBitVec w1) e (UBitVec w2) = coerce (SBitVec w1) e (SBitVec w2)
coerce (FP ex si) e (SBitVec w) = Just $ fp2bv ex si e w
coerce (FP ex si) e (UBitVec w) = Just $ fp2bv ex si e w
coerce (SBitVec w) e (FP ex si) = Just $ bv2fp w e ex si
coerce orig@(UBitVec w) e (FP ex si) = do
  let t = SBitVec (w + 1)
  signedE <- coerce orig e t
  coerce t signedE (FP ex si)
coerce (FP ex si) e Boolean = Just $ _not (fpiszero ex si e)
coerce (SBitVec w) e Boolean = Just $ _not (_eq e (bv 0 w))
coerce (UBitVec w) e Boolean = Just $ _not (_eq e (bv 0 w))
coerce Boolean e (FP ex si) = Just $ "(if " ++ e ++ " " ++ fpone ex si ++ " " ++ fpzero ex si ++ ")"
coerce (Vector n t1) e (Vector m t2) | n == m = do
  v <- coerce t1 "v" t2
  return $ "(let ([v " ++ e ++ "]) (vector" ++ concatMap (\i -> " (let ([v (vector-ref v " ++ show i ++ ")]) " ++ v ++ ")") [0..(n-1)] ++ ")"
coerce (Vector _ t1) e t2 | not (isVector t2) = do
  -- EPICS converts vectors to scalars by taking element 0
  coerce t1 ("(vector-ref " ++ e ++ " 0)") t2
coerce _ _ _ = Nothing

havocValue :: RealType -> String
havocValue = makeSymbolicValue "undefined-behavior"

coerceOrDie :: Record -> RealType -> String -> RealType -> String
coerceOrDie r t1 e t2 =
  case coerce t1 e t2 of
    Just e' -> e'
    Nothing ->
      warningInRecord r ("cannot coerce " ++ show t1 ++ " to " ++ show t2 ++ " in record " ++ recordNameToStr (r_name r))
      havocValue t2

-- computeExpAsType r f e ty
--     returns expression for computing the value of e where
--       r is the record in which e is being computed
--       f is the name of the calculation field from which e was derived
--       ty is the expected result type
computeExpAsType :: Record -> FieldName -> Exp -> RealType -> String
computeExpAsType r calcField (EVal n) Character
  | fromIntegral (fromIntegral (floor n) :: Int8) == n = bv (floor n) 8
  | otherwise = errorInRecord r $ "cannot parse " ++ show n ++ " as a char"
computeExpAsType r calcField (ECond e1 e2 e3) t =
  let e1' = computeExpAsType r calcField e1 Boolean in
  let e2' = computeExpAsType r calcField e2 t in
  let e3' = computeExpAsType r calcField e3 t in
  "(if " ++ e1' ++ " " ++ e2' ++ " " ++ e3' ++ ")"
computeExpAsType r calcField (ECall "ARR" [e]) (Vector n t) =
  "(let ([v " ++ computeExpAsType r calcField e t ++ "]) " ++ arrayOf n "v" ++ ")"
computeExpAsType r calcField e ty =
  computeExpInto r calcField e (\e' ty' -> coerceOrDie r ty' e' ty)

isEq (Character) v1 v2 = "(bveq " ++ v1 ++ " " ++ v2 ++ ")"
isEq (SBitVec _) v1 v2 = "(bveq " ++ v1 ++ " " ++ v2 ++ ")"
isEq (UBitVec _) v1 v2 = "(bveq " ++ v1 ++ " " ++ v2 ++ ")"
isEq (FP ex si) v1 v2 = fpeq ex si v1 v2
isEq (Vector 0 _) _ _ = "#t"
isEq (Vector n t) v1 v2 =
  macro2 v1 v2 $ "(and " ++
    concatMap (\i -> ' ' : isEq t ("(vector-ref v1 " ++ show i ++ ")") ("(vector-ref v2 " ++ show i ++ ")")) [0..(n-1)] ++
  ")"
isEq t _ _ = notImplemented $ "= on type " ++ show t

-- TODO: MIN/MAX on floating-point is implemented in EPICS like so (calcPerform.c):
-- while (--nargs) {
--     top = *ptop--;
--     if (*ptop < top || isnan(top))
--         *ptop = top;
-- }

computeMin (SBitVec _) = foldl (\prev next -> "(let ([v1 " ++ prev ++ "] [v2 " ++ next ++ "]) (if (bvslt v1 v2) v1 v2))")
computeMin (UBitVec _) = foldl (\prev next -> "(let ([v1 " ++ prev ++ "] [v2 " ++ next ++ "]) (if (bvult v1 v2) v1 v2))")
computeMin (FP ex si) = foldl (\prev next -> "(let ([v1 " ++ prev ++ "] [v2 " ++ next ++ "]) (if " ++ fplt ex si "v1" "v2" ++ " v1 v2))")

computeMax (SBitVec _) = foldl (\prev next -> "(let ([v1 " ++ prev ++ "] [v2 " ++ next ++ "]) (if (bvsgt v1 v2) v1 v2))")
computeMax (UBitVec _) = foldl (\prev next -> "(let ([v1 " ++ prev ++ "] [v2 " ++ next ++ "]) (if (bvugt v1 v2) v1 v2))")
computeMax (FP ex si) = foldl (\prev next -> "(let ([v1 " ++ prev ++ "] [v2 " ++ next ++ "]) (if " ++ fpgt ex si "v1" "v2" ++ " v1 v2))")

macro1 v e     = "(let ([v " ++ v ++ "]) " ++ e ++ ")"
macro2 v1 v2 e = "(let ([v1 " ++ v1 ++ "] [v2 " ++ v2 ++ "]) " ++ e ++ ")"

plus (Character) v1 v2 = ("(bvadd " ++ v1 ++ " " ++ v2 ++ ")")
plus (SBitVec _) v1 v2 = ("(bvadd " ++ v1 ++ " " ++ v2 ++ ")")
plus (UBitVec _) v1 v2 = ("(bvadd " ++ v1 ++ " " ++ v2 ++ ")")
plus (FP ex si) v1 v2 = (fpadd ex si v1 v2)
plus (Vector n t) v1 v2 = macro2 v1 v2 $ "(vector" ++ concatMap (\i -> ' ' : plus t ("(vector-ref v1 " ++ show i ++ ")") ("(vector-ref v2 " ++ show i ++ ")")) [0..(n-1)] ++ ")"
plus t _ _ = notImplemented $ "+ over type " ++ show t

computeExpInto :: Record -> FieldName -> Exp -> (String -> RealType -> String) -> String
computeExpInto r calcField (EName f) k =
  -- Note on VAL in calc expressions:
  -- from https://wiki-ext.aps.anl.gov/epics/index.php/RRM_3-14_Calcout:
  --   "The keyword VAL returns the current contents of the expression's result
  --    field, i.e. the VAL field for the CALC expression and the OVAL field for
  --    the OCAL expression."
  -- See also:
  --    http://www.aps.anl.gov/bcda/synApps/calc/aCalcoutRecord.html
  --    http://www.aps.anl.gov/bcda/synApps/calc/sCalcoutRecord.html
  let t = realType r f in
  case (calcField, f) of
    ("OCAL", "VAL")  -> k (get r "OVAL") t
    ("OCAL", "AVAL") -> k (get r "OAV") t -- acalcout docs are pretty clear on this point
    ("OCAL", "SVAL") -> k (get r "OSV") t -- it is implied (but not stated) that this is correct
    _ -> k (get r f) t
computeExpInto r calcField (EVal v) k =
  k ("(bv " ++ truncateDouble r v ++ " 64)") f64
computeExpInto r calcField (EStr s) k =
  let t = (Vector (arrLen r) Character) in
  k (parseConcreteValue r s t) t
computeExpInto r calcField (ECall f es) k =
  case (f, es) of
    ("ABS", [e]) -> computeExpInto r calcField e (\v t -> case t of
      FP ex si -> k (fpabs ex si v) t
      _ -> notImplemented $ "function " ++ f ++ " on " ++ show e ++ " of type " ++ show t)
    ("ARR", [e]) -> computeExpInto r calcField e (\v t ->
      let len = arrLen r in
      k ("(let ([v " ++ v ++ "]) " ++ arrayOf len "v" ++ ")") (Vector len t))
    ("FLOOR", [e]) -> computeExpInto r calcField e (\v t -> case t of
      FP ex si -> k (fpfloor ex si v) t
      _ -> notImplemented $ "function " ++ f ++ " on " ++ show e ++ " of type " ++ show t)
    ("CEIL", [e]) -> computeExpInto r calcField e (\v t -> case t of
      FP ex si -> k (fpceil ex si v) t
      _ -> notImplemented $ "function " ++ f ++ " on " ++ show e ++ " of type " ++ show t)
    ("PRINTF", _) ->
      let t = Vector (arrLen r) Character in
      warningInRecord r "PRINTF ignored" $ k (computeExpAsType r calcField (ECall "ARR" [(EVal 0)]) t) t
    ("SSCANF", _) ->
      warningInRecord r "SSCANF ignored" $ k (computeExpAsType r calcField (EVal 0) f64) f64
    ("MIN", []) -> errorInRecord r "MIN called with no arguments"
    ("MIN", e:es) -> computeExpInto r calcField e (\v t ->
      let vs = map (\ee -> computeExpAsType r calcField ee t) es in
      computeMin t v vs)
    ("MAX", []) -> errorInRecord r "MAX called with no arguments"
    ("MAX", e:es) -> computeExpInto r calcField e (\v t ->
      let vs = map (\ee -> computeExpAsType r calcField ee t) es in
      computeMax t v vs)
    _ -> notImplemented ("unknown function " ++ show f ++ " (in record " ++ recordNameToStr (r_name r) ++ ")") (k (fpzero 11 53) f64)
computeExpInto r calcField (EUnaryOp Not e) k =
  k ("(not " ++ (computeExpAsType r calcField e Boolean) ++ ")") Boolean
computeExpInto r calcField (EUnaryOp op e) k =
  let long = typeDenote LONG in
  computeExpInto r calcField e (\v t ->
    case (op, t) of
      (Neg, SBitVec _) -> k ("(bvneg " ++ v ++ ")") t
      (Neg, _) | t == f64 -> k (coerceOrDie r long ("(bvneg " ++ (coerceOrDie r t v long) ++ ")") t) t -- this is how calcPerform.c implements it
      (BitNot, SBitVec _) -> k ("(bvnot " ++ v ++ ")") t
      (BitNot, UBitVec _) -> k ("(bvnot " ++ v ++ ")") t
      (BitNot, _) | t == f64 -> k (coerceOrDie r long ("(bvnot " ++ (coerceOrDie r t v long) ++ ")") t) t -- this is how calcPerform.c implements it
      _ -> notImplemented $ "" ++ show op ++ " on " ++ show e ++ " of type " ++ show t)
computeExpInto r calcField e@(EBinOp op e1 e2) k =
  case op of
    Eq -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      isEq t v1 v2)
    Ne -> k (computeExpAsType r calcField (EUnaryOp Not (EBinOp Eq e1 e2)) Boolean) Boolean
    Lt -> computeExpInto r calcField e1 (\v1 t -> k (_lt t v1 (computeExpAsType r calcField e2 t)) Boolean)
    Le -> computeExpInto r calcField e1 (\v1 t -> k (_le t v1 (computeExpAsType r calcField e2 t)) Boolean)
    Gt -> computeExpInto r calcField e1 (\v1 t -> k (_gt t v1 (computeExpAsType r calcField e2 t)) Boolean)
    Ge -> computeExpInto r calcField e1 (\v1 t -> k (_ge t v1 (computeExpAsType r calcField e2 t)) Boolean)
    Minus -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      case t of
        SBitVec _ -> k ("(bvsub " ++ v1 ++ " " ++ v2 ++ ")") t
        UBitVec _ -> k ("(bvsub " ++ v1 ++ " " ++ v2 ++ ")") t
        FP ex si -> k (fpsub ex si v1 v2) t
        _ -> notImplemented $ "- on " ++ show e1 ++ ", " ++ show e2)
    Plus -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      k (plus t v1 v2) t)
    Times -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      case t of
        SBitVec _ -> k ("(bvmul " ++ v1 ++ " " ++ v2 ++ ")") t
        UBitVec _ -> k ("(bvmul " ++ v1 ++ " " ++ v2 ++ ")") t
        FP ex si -> k (fpmul ex si v1 v2) t
        _ -> notImplemented $ "* on " ++ show e1 ++ ", " ++ show e2)
    Div -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      case t of
        SBitVec _ -> k ("(bvsdiv " ++ v1 ++ " " ++ v2 ++ ")") t
        UBitVec _ -> k ("(bvudiv " ++ v1 ++ " " ++ v2 ++ ")") t
        FP ex si -> k (fpdiv ex si v1 v2) t
        _ -> notImplemented $ "/ on " ++ show e1 ++ ", " ++ show e2)
    Mod -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      let long@(SBitVec longWidth) = typeDenote LONG in
      case t of
        SBitVec _ -> k ("(bvsmod " ++ v1 ++ " " ++ v2 ++ ")") t
        UBitVec _ -> k ("(bvurem " ++ v1 ++ " " ++ v2 ++ ")") t
        FP ex si -> k ("(let ([v1 " ++ (coerceOrDie r t v1 long) ++ "] [v2 " ++ (coerceOrDie r t v2 long) ++ "]) (if (bveq v2 " ++ bv 0 longWidth ++ ") " ++ fpnan ex si ++ " " ++ coerceOrDie r long "v2" t ++ "))") t -- this is how calcPerform.c implements it
        _ -> notImplemented $ "% on " ++ show e1 ++ ", " ++ show e2)
    Or  -> k ("(or  " ++ computeExpAsType r calcField e1 Boolean ++ " " ++ computeExpAsType r calcField e2 Boolean ++ ")") Boolean
    And -> k ("(and " ++ computeExpAsType r calcField e1 Boolean ++ " " ++ computeExpAsType r calcField e2 Boolean ++ ")") Boolean
    BitAnd -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      let long = typeDenote LONG in
      case t of
        SBitVec _ -> k ("(bvand " ++ v1 ++ " " ++ v2 ++ ")") t
        UBitVec _ -> k ("(bvand " ++ v1 ++ " " ++ v2 ++ ")") t
        FP _ _    -> k ("(bvand " ++ coerceOrDie r t v1 long ++ " " ++ coerceOrDie r t v2 long ++ ")") long -- this is how calcPerform.c implements it
        _ -> notImplemented $ "& on " ++ show e1 ++ ", " ++ show e2)
    BitOr -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      let long = typeDenote LONG in
      case t of
        SBitVec _ -> k ("(bvor " ++ v1 ++ " " ++ v2 ++ ")") t
        UBitVec _ -> k ("(bvor " ++ v1 ++ " " ++ v2 ++ ")") t
        FP _ _    -> k ("(bvor " ++ coerceOrDie r t v1 long ++ " " ++ coerceOrDie r t v2 long ++ ")") long -- this is how calcPerform.c implements it
        _ -> notImplemented $ "& on " ++ show e1 ++ ", " ++ show e2)
    BitXor -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      let long = typeDenote LONG in
      case t of
        SBitVec _ -> k ("(bvxor " ++ v1 ++ " " ++ v2 ++ ")") t
        UBitVec _ -> k ("(bvxor " ++ v1 ++ " " ++ v2 ++ ")") t
        FP _ _    -> k ("(bvxor " ++ coerceOrDie r t v1 long ++ " " ++ coerceOrDie r t v2 long ++ ")") long -- this is how calcPerform.c implements it
        _ -> notImplemented $ "& on " ++ show e1 ++ ", " ++ show e2)
    ShiftRight -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      let long = typeDenote LONG in
      case t of
        SBitVec _ -> k ("(bvashr " ++ v1 ++ " " ++ v2 ++ ")") t
        UBitVec _ -> k ("(bvlshr " ++ v1 ++ " " ++ v2 ++ ")") t
        FP _ _    -> k ("(bvashr " ++ coerceOrDie r t v1 long ++ " " ++ coerceOrDie r t v2 long ++ ")") long -- this is how calcPerform.c implements it
        _ -> notImplemented $ "& on " ++ show e1 ++ ", " ++ show e2)
    ShiftLeft -> computeExpInto r calcField e1 (\v1 t ->
      let v2 = computeExpAsType r calcField e2 t in
      let long = typeDenote LONG in
      case t of
        SBitVec _ -> k ("(bvshl " ++ v1 ++ " " ++ v2 ++ ")") t
        UBitVec _ -> k ("(bvshl " ++ v1 ++ " " ++ v2 ++ ")") t
        FP _ _    -> k ("(bvshl " ++ coerceOrDie r t v1 long ++ " " ++ coerceOrDie r t v2 long ++ ")") long -- this is how calcPerform.c implements it
        _ -> notImplemented $ "& on " ++ show e1 ++ ", " ++ show e2)
    _ -> error $ "unknown operator " ++ show op ++ " (in record " ++ recordNameToStr (r_name r) ++ ")"
computeExpInto r calcField (ECond e1 e2 e3) k =
  "(if " ++ computeExpAsType r calcField e1 Boolean ++ " "
    ++ "(begin " ++ computeExpInto r calcField e2 k ++ ") "
    ++ "(begin " ++ computeExpInto r calcField e3 k ++ "))"
computeExpInto r calcField (EAssign f e) k =
  let t = realType r f in
  let e' = computeExpAsType r calcField e t in
  k (macro1 e' (set r f "v" ++ " v")) t
computeExpInto r calcField (ESeq e1 e2) k =
  computeExpInto r calcField e1 (\v1 _ ->
    computeExpInto r calcField e2 (\v2 t ->
      -- From https://wiki-ext.aps.anl.gov/epics/index.php/RRM_3-14_Calculation:
      --   The string may contain a series of expressions separated by a semi-colon character ';'
      --   any one of which may actually provide the calculation result; however all of the other
      --   expressions included must assign their result to a variable.
      k ("(let ([v1 " ++ v1 ++ "] [v2 " ++ v2 ++ "]) " ++ (if isAssignment e1 then "v2" else "v1") ++ ")") t))
computeExpInto r calcField (ESubarray e (EVal start) (EVal end)) k =
  -- NOTE: both bounds are INCLUSIVE.
  -- TODO: the EPICS source code does nonsense like: if (i < 0) i += arraySize
  computeExpInto r calcField e (\v t ->
    case t of
      Vector n tt ->
        let start' = (truncate start) :: Integer in
        let end'   = (truncate end  ) :: Integer in
        k (macro1 v $ "(vector" ++ concatMap (\i -> if i + start' <= end' then " (vector-ref v " ++ show i ++ ")" else " " ++ mkZero tt) [0 .. (arrLen r - 1)] ++ ")") t
      _ -> errorInRecord r $ "cannot take subarray of non-vector " ++ show t)
computeExpInto r calcField (ESubarrayInPlace e (EVal start) (EVal end)) k =
  -- NOTE: both bounds are INCLUSIVE.
  -- TODO: the EPICS source code does nonsense like: if (i < 0) i += arraySize
  computeExpInto r calcField e (\v t ->
    case t of
      Vector n tt ->
        let start' = (truncate start) :: Integer in
        let end'   = (truncate end  ) :: Integer in
        k (macro1 v $ "(vector" ++ concatMap (\i -> if i >= start' && (if sliceSemantics == InclusiveExclusive then i < end' else i <= end') then " (vector-ref v " ++ show i ++ ")" else " " ++ mkZero tt) [0 .. (n - 1)] ++ ")") t
      _ -> errorInRecord r $ "cannot take subarray of non-vector " ++ show t)
computeExpInto _ _ e _ = notImplemented $ "computeExpInto (" ++ show e ++ ")"

-- Reads the NELM field (number of array elements).
-- For scalcout records, returns the length of string-value fields (40).
arrLen :: Record -> Integer
arrLen r | r_type r == "scalcout" = 40
arrLen r =
  let
    n   = read $ readField r "NELM" :: Integer
    use = if r `hasField` "NUSE"
      then read $ readField r "NUSE" :: Integer
      else n
  in
    -- technically speaking these can be different, but life is easier for us
    -- if they aren't
    if (n == use || use == 0)
      then n
      else error ("unsupported behavior: on " ++ recordNameToStr (r_name r) ++ ", NELM != NUSE")

-- Reads the FTVL field (array type)
arrTy :: Record -> FieldType
arrTy r | r_type r == "acalcout" = DOUBLE
arrTy r =
  let ftvl = readField r "FTVL" in
  case ftvl of
    "CHAR"   -> CHAR
    "UCHAR"  -> UCHAR
    "SHORT"  -> SHORT
    "USHORT" -> USHORT
    "LONG"   -> LONG
    "ULONG"  -> ULONG
    "FLOAT"  -> FLOAT
    "DOUBLE" -> DOUBLE
    "ENUM"   -> ENUM
    _ -> error $ "unknown value for FTVL on " ++ recordNameToStr (r_name r) ++ ": '" ++ ftvl ++ "'"

arrayOf :: Integer -> String -> String
arrayOf n v =
  "(vector" ++ concat (take (fromIntegral n) $ repeat $ ' ' : v) ++ ")"

isAssignment (EAssign _ _) = True
isAssignment _ = False

-- Different fields in EPICS behave differently when dereferencing input links.
-- Generally INP* fields ignore constant values:
--  > If the INP link type is CONSTANT recGblGetLinkValue() does nothing and
--  > returns with a status of zero.
-- (https://wiki-ext.aps.anl.gov/epics/index.php/RRM_3-14_Common#Input_Records)
-- While generally DOL* fields handle constant values:
--  > The DOL field can also be a constant in which case the VAL field is
--  > initialized to the constant value.
-- (https://wiki-ext.aps.anl.gov/epics/index.php/RRM_3-14_Data_Fanout)
data ConstantHandling = CopyConstants | IgnoreConstants deriving (Eq, Ord, Show)

-- fetchVal mode r f dst db
-- Read the value pointed to by input link r.f and put it in r.dst in database
-- db. The `mode` parameter specifies how to handle constant values in r.f.
fetchVal :: ConstantHandling -> Record -> FieldName -> FieldName -> Database -> String
fetchVal mode r f dst db =
  processFieldLink IfPassive r f db ++
  copyVal mode r f dst db

writeVal :: Record -> FieldName -> FieldName -> Database -> String
writeVal r f dst db =
  case parseFieldLink (readField r dst) of
    FieldLink { fl_record = rn, fl_field = ff, fl_ms = ms } ->
      case findRecord [Literal rn] db of
        Just rr ->
          set rr ff (coerceOrDie r (realType r f) (get r f) (realType rr ff)) ++
          inheritSeverity ms r rr ++ -- rr is the "destination" here
          if ff == "PROC"
            then process rr
            else processFieldLink IfPassive r dst db
        _ -> ""
    _ -> ""

copyVal :: ConstantHandling -> Record -> FieldName -> FieldName -> Database -> String
copyVal mode r f dst db =
  case parseFieldLink (readField r f) of
    Constant n | mode == IgnoreConstants -> warningInRecord r ("ignoring constant in " ++ f ++ " field") ""
    Constant n -> set r dst (bv (truncateDoubleToInt r n) 64)
    FieldLink { fl_record = rn, fl_field = ff, fl_ms = ms } ->
      case findRecord [Literal rn] db of
        Just rr ->
          set r dst (coerceOrDie r (realType rr ff) (get rr ff) (realType r dst)) ++
          inheritSeverity ms rr r -- r is the "destination" here
        _ -> ""
    _ -> ""

data ProcessMode = Always | IfPassive

processFieldLink :: ProcessMode -> Record -> FieldName -> Database -> String
processFieldLink mode r f db =
  case parseFieldLink (readField r f) of
    FieldLink { fl_record = rn, fl_pp = pp } | shouldProcess mode pp ->
      case findRecord [Literal rn] db of
        Just rr | scanMode rr == Passive -> process rr
        _ -> ""
    _ -> ""
  where
    shouldProcess Always _ = True
    shouldProcess IfPassive ProcessPassive = True
    shouldProcess _ _ = False

process r = "(process_" ++ mangleRecord (r_name r) ++ ")\n"

calcInputs = ["INP" ++ [c] | c <- ['A'..'L']]
calcVars = [[c] | c <- ['A'..'L']]
acalcoutInputs = ["IN" ++ [c,c] | c <- ['A'..'L']]
acalcoutVars = [[c,c] | c <- ['A'..'L']]
fanoutLinks = ["LNK" ++ [n] | n <- ['1'..'6']]
seqInputs = ["DOL" ++ [n] | n <- ['1'..'9'] ++ ['A']]
seqVars = ["DO" ++ [n] | n <- ['1'..'9'] ++ ['A']]
seqOutputs = ["LNK" ++ [n] | n <- ['1'..'9'] ++ ['A']]
dfanoutOutputs = ["OUT" ++ [c] | c <- ['A'..'H']]

parseExpOrFail :: String -> Exp
parseExpOrFail s =
  --trace ("parsing " ++ show s) $
  case parseExp s of
    Left err -> error (show err)
    Right e -> e

_true = "#t"
_false = "#f"
_noop = "'()"
_and x y = "(and " ++ x ++ " " ++ y ++ ")"
_or x y = "(or " ++ x ++ " " ++ y ++ ")"
_eq x y = "(equal? " ++ x ++ " " ++ y ++ ")"
_lt t x y =
  case t of
    SBitVec _ -> ("(bvslt " ++ x ++ " " ++ y ++ ")")
    UBitVec _ -> ("(bvult " ++ x ++ " " ++ y ++ ")")
    FP ex si -> (fplt ex si x y)
    _ -> error "no implementation of < for " ++ show t
_le t x y =
  case t of
    SBitVec _ -> ("(bvsle " ++ x ++ " " ++ y ++ ")")
    UBitVec _ -> ("(bvule " ++ x ++ " " ++ y ++ ")")
    FP ex si -> (fple ex si x y)
    _ -> error "no implementation of <= for " ++ show t
_gt t x y =
  case t of
    SBitVec _ -> ("(bvsgt " ++ x ++ " " ++ y ++ ")")
    UBitVec _ -> ("(bvugt " ++ x ++ " " ++ y ++ ")")
    FP ex si -> (fpgt ex si x y)
    _ -> error "no implementation of > for " ++ show t
_ge t x y =
  case t of
    SBitVec _ -> ("(bvsge " ++ x ++ " " ++ y ++ ")")
    UBitVec _ -> ("(bvuge " ++ x ++ " " ++ y ++ ")")
    FP ex si -> (fpge ex si x y)
    _ -> error "no implementation of >= for " ++ show t
_not x = "(not " ++ x ++ ")"
_if cond thenBranch elseBranch = "(if " ++ cond ++ " " ++ thenBranch ++ " " ++ elseBranch ++ ")"
_seq x y = "(begin " ++ x ++ " " ++ y ++ ")"

menuToValue :: Record -> FieldName -> String -> String
menuToValue r fn val =
  case typeOfField r fn of
    MENU options
      | Just i <- elemIndex val options -> parseConcreteValue r (show i) (realType r fn)
      | otherwise -> errorInRecord r $ "invalid value " ++ show val ++ " for menu field " ++ show fn
    _ -> errorInRecord r $ "field " ++ show fn ++ " is not a MENU type"

-- based on calcRecord.c.
-- Each EPICS record type has its *own* implementation of this, so someday we
-- might want to verify that this is how it behaves for all of them.
checkAnalogAlarms :: Record -> String
checkAnalogAlarms r =
  "(cond" ++
  flip concatMap [
      ("HHSV", "HIHI", Ge, "HIHI"),
      ("LLSV", "LOLO", Le, "LOLO"),
      ("HSV",  "HIGH", Ge, "HIGH"),
      ("LSV",  "LOW",  Le, "LOW")] (\(alarmSeverity, badVal, op, status) ->
    "\n    [" ++ computeExpAsType r "CALC" (EBinOp And (EName alarmSeverity) (EBinOp op (EName "VAL") (EName badVal))) Boolean ++ " "
      ++ updateAlarmState r (menuToValue r "STAT" status) (get r alarmSeverity)
      ++ "]") ++
  ")\n"

-- see recGblSetSevr in recGbl.h
-- usage: updateAlarmState [r] [status] [severity]
-- returns true if severity was updated
updateAlarmState :: Record -> String -> String -> String
updateAlarmState r status severity =
  let ($<) = _lt (realType r "SEVR") in
  _if (get r "SEVR" $< severity)
    (set r "STAT" status `_seq` set r "SEVR" severity `_seq` _true)
    _false

-- see inherit_severity in dbAccess.c
-- usage: inheritSeverity [flag] [src] [dst]
-- the [dst] record will inherit severity from [src] depending on [flag]
inheritSeverity :: MsFlag -> Record -> Record -> String
inheritSeverity NonMaximizeSeverity _ _ = _noop
inheritSeverity MaximizeSeverityIfInvalid src dst =
  let ($>=) = _ge (realType src "SEVR") in
  _if ((get src "SEVR") $>= (menuToValue src "STAT" "INVALID_ALARM"))
    (inheritSeverity MaximizeSeverity src dst)
    _noop
inheritSeverity MaximizeSeverity src dst =
  updateAlarmState dst (menuToValue src "STAT" "LINK") (get src "SEVR")
inheritSeverity MaximizeStatusAndSeverity src dst =
  updateAlarmState dst (get src "STAT") (get src "SEVR")

mkProcRoutine :: Database -> Record -> String
mkProcRoutine db r =
  let pact_width = (let t = realType r "PACT" in case t of { SBitVec w -> w; UBitVec w -> w; _ -> errorInRecord r ("PACT has non-bitvector type " ++ show t) }) in
  "(define (process_" ++ mangleRecord (r_name r) ++ ")\n" ++
  "  (cond [(bveq " ++ get r "PACT" ++ " " ++ bv 0 pact_width ++ ")\n" ++
  "    (record-trace (StartProcessing " ++ show (recordNameToStr $ r_name r) ++ "))\n" ++
  "    (start-processing-hook " ++ show (recordNameToStr $ r_name r) ++ ")\n" ++
  set r "PACT" (bv 1 pact_width) ++

  -- do type-specific things
  (case r_type r of
    "calc" ->
      let val = computeExpAsType r "CALC" (parseExpOrFail $ readFieldWithDefault r "CALC" "VAL") f64
      in
        concatMap (\(inp,v) -> fetchVal IgnoreConstants r inp v db) (zip calcInputs calcVars) ++
        set r "VAL" val
    t | t `elem` ["calcout", "acalcout", "scalcout"] ->
      -- For a lot of the details here I had to go digging in aCalcoutRecord.c.
      -- I've documented some of the weirdnesses inline.

      -- parse expressions
      let calcExpr = parseExpOrFail (readFieldWithDefault r "CALC" "VAL") in
      let ocalExpr = parseExpOrFail (readFieldWithDefault r "OCAL" "VAL") in

      -- fetch inputs
      concatMap (\(inp,v) -> fetchVal IgnoreConstants r inp v db) (zip calcInputs calcVars) ++
      (if t `elem` ["acalcout", "scalcout"]
        then concatMap (\(inp,v) -> fetchVal IgnoreConstants r inp v db) (zip acalcoutInputs acalcoutVars)
        else _noop) ++

      "(let ([v " ++ get r "VAL" ++ "]) (begin " ++ -- save old output value (it affects OOPT)

        -- calculate CALC and save it to the right place
        computeExpInto r "CALC" calcExpr (\val ty ->
          case ty of {
            _ | t == "acalcout", Vector _ ty' <- ty, ty' == typeDenote (arrTy r) -> set r "AVAL" val;
            _ | t == "scalcout", Vector _ Character <- ty -> set r "SVAL" val;
            _ | Just val' <- coerce ty val f64 -> set r "VAL" val';
            _ -> error $ "CALC expression on " ++ t ++ " record " ++ recordNameToStr (r_name r) ++ " produces value of type " ++ show ty }) ++

        -- figure out what gets written where
        let writeOutput = "(begin " ++ case readField r "DOPT" of {
          "Use CALC" ->
            -- VAL gets copied to OVAL and AVAL gets copied to OAV
            set r "OVAL" (get r "VAL") ++
            if t == "acalcout" then set r "OAV" (get r "AVAL") else _noop ++
            if t == "scalcout" then set r "OSV" (get r "SVAL") else _noop ++
            writeVal r "VAL" "OUT" db;
          "Use OCAL" ->
            -- TODO: What does EPICS do if the record produces a value of the wrong type?
            (if definesValueForField r "OCAL"
              then id
              else warning $ "record " ++ recordNameToStr (r_name r) ++ " specifies 'Use OCAL' but does not specify OCAL")
            computeExpInto r "OCAL" ocalExpr (\val ty ->
              let go v f = set r f v ++ writeVal r f "OUT" db in
              case ty of {
                _ | Just val' <- coerce ty val f64 -> go val' "OVAL";
                _ | t == "acalcout", Vector _ ty' <- ty, ty' == typeDenote (arrTy r) -> go val "OAV";
                _ | t == "scalcout", Vector _ Character <- ty -> go val "OSV";
                _ -> error $ "OCAL expression on " ++ t ++ " record " ++ recordNameToStr (r_name r) ++ " produces value of type " ++ show ty });
          _ ->
            error $ "unknown value " ++ show (readField r "DOPT") ++ " for DOPT on record " ++ recordNameToStr (r_name r)} ++ " " ++ _noop ++ ")" in

        -- write output
        (case readField r "OOPT" of
          "Every Time" ->
            writeOutput
          "On Change" ->
            _if (_eq "v" (get r "VAL"))
              {- then -} _noop
              {- else -} writeOutput
          "When Zero" ->
            _if (_eq (get r "VAL") "0")
              {- then -} writeOutput
              {- else -} _noop
          "When Non-zero" ->
            _if (_eq (get r "VAL") "0")
              {- then -} _noop
              {- else -} writeOutput
          "Transition To Zero" ->
            _if (_and (_not (_eq "v" "0")) (_eq (get r "VAL") "0"))
              {- then -} writeOutput
              {- else -} _noop
          "Transition To Non-zero" ->
            _if (_and (_eq "v" "0") (_not (_eq (get r "VAL") "0")))
              {- then -} writeOutput
              {- else -} _noop
          "Never" ->
            _noop
          _ ->
            error $ "unknown value " ++ show (readField r "OOPT") ++ " for OOPT on record " ++ recordNameToStr (r_name r)) ++

        " " ++ _noop ++ "))"
    "bi" ->
      -- This record is a fractal of insanity.
      -- Processing works like this:
      --  1. Read new value from INP into RVAL
      --  2. Conversion
      --     if INP is a constant or a field link, do nothing
      --     else set RVAL = VAL ? 1 : 0
      --  3. Check alarms
      --     if VAL > 1, return (!?)
      --     if VAL == 0:
      --        if SEVR<ZSV: STAT="STATE_ALARM", SEVR=ZSV
      --     else:
      --        if SEVR<OSV: STAT="STATE_ALARM", SEVR=OSV
      --     if VAL==LALM: return
      --     if SEVR<COSV: STAT="COS_ALARM", SEVR=COSV
      --     LALM=VAL

      -- read link & conversion
      (case parseFieldLink (readField r "INP") of
        HardwareAddr _ ->
          set r "VAL" (computeExpAsType r "CALC" (ECond (EName "RVAL") (EVal 1) (EVal 0)) (realType r "VAL"))
        _ ->
          fetchVal IgnoreConstants r "INP" "VAL" db)
    t | t `elem` ["ai", "bi", "mbbi", "longin", "stringin"] ->
      fetchVal IgnoreConstants r "INP" "VAL" db
    t | t `elem` ["ao", "bo", "mbbo", "longout", "stringout"] ->
      (if readField r "OMSL" == "closed_loop"
        then fetchVal CopyConstants r "DOL" "VAL" db
        else "")
    "seq" ->
      -- TODO: should we support DLYn fields? Jon doesn't use them, but they
      -- allow for weird interleavings (if I understand correctly)...
      concatMap (\i ->
        fetchVal CopyConstants r (seqInputs !! i) (seqVars !! i) db ++
        writeVal r (seqVars !! i) (seqOutputs !! i) db) [0 .. (length seqInputs - 1)]
    "fanout" ->
      concatMap (\l -> processFieldLink Always r l db) fanoutLinks
    "dfanout" ->
      fetchVal CopyConstants r "DOL" "VAL" db ++
      concatMap (\l -> writeVal r "VAL" l db) dfanoutOutputs
    "waveform" -> "" -- this record type is entirely for device interaction
    ty -> warning ("unsupported record type in ToRosette.hs: " ++ r_type r) $ "(eprintf \"    **** Unsupported record " ++ (recordNameToStr $ r_name r) ++ " of type " ++ r_type r ++ "\\n\")\n") ++

  -- check alarms
  (case r_type r of
    t | t `elem` ["calc", "calcout", "acalcout", "scalcout", "ao", "ai"] -> checkAnalogAlarms r
    _ -> _noop) ++

  -- scan flnk
  (case parseRecordLink (readField r "FLNK") of
    Just rn ->
      case findRecord rn db of
        Just rr -> process rr
        _ -> ""
    _ -> "") ++

  set r "PACT" (bv 0 pact_width) ++
  "    (record-trace (EndProcessing " ++ show (recordNameToStr $ r_name r) ++ "))\n" ++
  "    (end-processing-hook " ++ show (recordNameToStr $ r_name r) ++ ")" ++
  "]" ++
  "[#t (record-trace (SkipProcessing " ++ show (recordNameToStr $ r_name r) ++ "))]))\n"
